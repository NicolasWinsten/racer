<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WikiGame</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="styles/common.css">
    <link rel="stylesheet" href="styles/Vector.css">
    <link rel="stylesheet" href="styles/commonPrint.css">
    <link rel="stylesheet" href="styles/shared.css">
    <link rel="stylesheet" href="styles/loaded.css">
    <style>
        .wikilink {color: blue !important; text-decoration: underline !important}
        body {background-color: #ebece5 !important;}
        .navbar {background-color: #d0d2c4;}
        .previewImage img {width: 150px; height: auto;}
        .toast {max-width: 200px;}
        a.hoverUnderline:hover {text-decoration: underline !important}
    </style>



</head>
<body>
    <div id="app"></div>
    <div class="toast-container position-fixed bottom-0 end-0 p-3" id="toastbox"></div>
    <div class="m-3" style="text-align: right; font-style: italic; font-size: smaller;"> -- <a class="wikilink" href="http://nicolaswinsten.com">Nicolas Winsten</a></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
    <script src="assets/clipboard.min.js"></script>
    <script src="assets/peerjs.min.js"></script>
    <script src="app.js"></script>

    <script>
        const app = Elm.Main.init({node: document.getElementById("app")});

        /*This app uses bootstrap tooltips but the popup elements are generated by the user, so we must activate them only once they have been created.
        This port signals when to activate the tooltips; requestAnimationFrame is to make sure they've been added to the dom beforehand*/

        app.ports.activateTooltipsSignal.subscribe(
            function(x) {
                requestAnimationFrame(function() {

                    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
                    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                      return new bootstrap.Tooltip(tooltipTriggerEl)
                    });

                });
            }
        );

        app.ports.activateClippySignal.subscribe(
            function(x) {
                requestAnimationFrame(function() {
                    new ClipboardJS('.clippybtn');
                });
            }
        );

        app.ports.makeToast.subscribe(
            function(msg) {
                console.log("activating toast:", msg);

                let temp = document.createElement('div');
                temp.innerHTML = "<div class='toast' role='alert' aria-live='assertive' aria-atomic='true'><div class='toast-body'>" + msg + "</div></div>";

                let el = temp.firstChild;
                document.getElementById("toastbox").appendChild(el);

                let toast = new bootstrap.Toast(el);
                toast.show();

                setTimeout(function() {
                    toast.hide();
                    setTimeout(function() {el.remove();}, 1000);
                }, 5000);
            }
        );


        /* code handling the Peer connections */

        var peer = null;
        var isHost = null;
        var hostConnection = null;
        var clientConnections = [];

        window.addEventListener("beforeunload", function(e){
           if (isHost && clientConnections.length > 0) {
                clientConnections.forEach(function(conn) {
                    conn.close();
                });
           } else if (hostConnection != null) {
                hostConnection.close()
           }
        }, false);

        function filterConns() {
            console.log("filtering connections");
            clientConnections = clientConnections.filter(function(conn) {
                return conn.open;
            });
        }


        function dataHandler(data) {
            console.log("received data:", data);
            app.ports.receiveData.send(data);
        }


        app.ports.makePeer.subscribe(
            function(str) {
                console.log("initializing peer: " + str);
                peer = new Peer(null, {debug : 2});

                peer.on('open', function(id) {
                    console.log("peer ID is " + id);
                    app.ports.receiveData.send({ id : id });

                    peer.on('error', function(err) {
                        console.log("Your peer has error:", err.type);
                        app.ports.receiveData.send({error : err.type});
                    });
                });

            }
        );


        app.ports.initPeer.subscribe(
            function(init) {
                isHost = init.isHost;
                console.log("isHost", isHost);

                if (isHost) {
                    console.log("hosting...");
                    peer.on('connection', function(conn) {
                        console.log("connection received from " + conn.peer + " : " + conn.metadata.username + " with uuid " + conn.metadata.uuid);
                        clientConnections.push(conn);


                        conn.on('open', function() {
                            app.ports.receiveData.send({peerConnect : {username : conn.metadata.username, uuid : conn.metadata.uuid}});
                            conn.on('data', dataHandler);

                            conn.on('close', function() {
                                filterConns();
                                console.log("connection to", conn.metadata.username, ":", conn.metadata.uuid, "was lost");
                                app.ports.receiveData.send({peerDisconnect : {uuid : conn.metadata.uuid}});
                            });

                            conn.on('error', function(err) {
                                console.log("connection error with", conn.metadata.username, ":", err);
                            });
                        });



                    });

                } else {
                    console.log("attempting connection to host " + init.connectId);

                    hostConnection = peer.connect(init.connectId, {metadata : {username : init.username, uuid : init.uuid}});
                    hostConnection.on('open', function() {
                        hostConnection.on('data', dataHandler);

                        hostConnection.on('close', function() {
                            console.log("connection from host lost");
                            app.ports.receiveData.send({hostLost : "Host connection was closed"});
                        });

                        hostConnection.on('error', function(err) {
                            console.log("connection error with host:", err);
                        });
                    });
                }

                app.ports.sendData.subscribe(
                    function(data) {
                        if (isHost) {
                            console.log("trying to send data to clients:", data);
                            clientConnections.forEach(function(conn) {
                                conn.send(data);
                            });
                        } else {
                            console.log("trying to send to host:", data);
                            hostConnection.send(data);
                        }
                    }
                );
            }
        );


    </script>



</body>
</html>